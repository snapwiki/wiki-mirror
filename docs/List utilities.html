<div class="mw-parser-output"><p>The <b>List utilities</b> library is used for data computation on lists.</p><h2><span class="mw-headline" id="Library_Description">Library Description</span></h2><p>Some standard functions of lists (reverse, sort, etc.)</p><h2><span class="mw-headline" id="Blocks">Blocks</span></h2><table class="wikitable"><tbody><tr><th>Block</th><th>Description</th><th>Example</th></tr><tr><td colspan="3"><i><big><a href="https://snapwiki.miraheze.org/wiki/Operators" title="Operators">Operators</a></big></i></td></tr><tr><td><code class="blocks">(sentence @arrowRight list []&nbsp;:: operators)</code></td><td>Takes a sentence in text string form and reports the sentence as a list of its words.</td><td><code class="blocks">(sentence @arrowRight list [Hello world.]&nbsp;:: operators)</code></td></tr><tr><td colspan="3"><i><big><a href="https://snapwiki.miraheze.org/wiki/Lists_(Block_Category)" title="Lists (Block Category)">Lists</a></big></i></td></tr><tr><td><code class="blocks">(@flash sort @list ordering with (&lt;&gt; @addInput)&nbsp;:: list)</code></td><td>Reports a sorted version of the list in its first input slot, using the comparison function in the second input slot. For a list of numbers, using &lt; as the comparison function will sort from low to high; using &gt; will sort from high to low.</td><td></td></tr><tr><td><code class="blocks">(@flash assoc [] @list&nbsp;:: list)</code></td><td>The second input is an "association list," a list of two-item lists. Each of those smaller lists has a "key" as its first item and a "value" as its second. ASSOC reports the first key-value pair in the association list whose key matches the first input.</td><td></td></tr><tr><td><p><code class="blocks">((#)) for each ((item)) in @list { }&nbsp;:: loop list</code></p></td><td>This block carries out the given script for each item of the given list, like the primitive FOR EACH.<p>What's different is that it provides the # variable, which will contain the item number in the list of each item in turn, 1 while processing item 1, and so on.</p></td><td></td></tr><tr><td><code class="blocks">(printable @list&nbsp;:: list)</code></td><td>Takes a (possibly deep) list as input, and reports a human-readable text form of the list (namely, Lisp notation).<p>Will not work on circular lists.</p></td></tr><tr><td><code class="blocks">(sentence [] @delInput @verticalEllipsis @addInput&nbsp;:: list)</code></td><td>SENTENCE is the main constructor for sentences, represented as lists of words. It takes zero or more inputs, each of which can be either a list or a text string. If a list, the input is assumed to be a list of words. If a text string, it is converted to a list of words using SENTENCEâ†’LIST. Then all the lists of words are appended to form a new list of words.<p>If the inputs are lists of lists rather than lists of words, SENTENCE, like APPEND, does only one level of flattening, reporting a list of all the items of all the input lists.</p></td><td></td></tr><tr><td><code class="blocks">(@flash zip @list @delInput @verticalEllipsis @addInput&nbsp;:: list)</code></td><td>ZIP takes any number of lists as inputs. The lists should all be the same length. ZIP reports a list of lists in which the first item is a list of all the first items, the second item is a list of all the second items, etc.<p>Viewing the inputs as the rows of a matrix, ZIP reports its transpose.</p></td><td></td></tr><tr><td><code class="blocks">([]&nbsp;:: list)</code></td><td>The identity function reports its input.</td><td></td></tr><tr><td><code class="blocks">(multimap (() @addInput) over @list @delInput @verticalEllipsis @addInput&nbsp;:: list)</code></td><td>Takes as input a function of N inputs and N lists.<p>The function is called with item 1 of all the lists as its inputs, with item 2 of all the lists as its inputs, and so on. (The lists should all be the same length.)</p></td><td></td></tr></tbody></table></div>