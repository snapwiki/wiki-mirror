<div class="mw-parser-output"><table style="border:1px solid #d9d9d9;border-top-left-radius:10px;border-top-right-radius:10px;margin-bottom: 0.5em;margin-left: 1em;float: right;clear: right;min-width:225px;background:white;color:#000000;"><tbody><tr><td colspan="2" style="padding:7px 20px;background-color:#f2f2f2;font-size:1.2em;text-align:center;border-bottom:1px solid #d9d9d9; border-top-left-radius:8px;border-top-right-radius:8px;">if on edge, bounce</td></tr><tr align="center"><td colspan="2" style="padding:0.5em;"><pre class="blocks">if on edge, bounce</pre></td></tr><tr><td><b>Category</b></td><td><a href="https://snapwiki.miraheze.org/wiki/Motion" title="Motion">Motion</a></td></tr><tr><td><b>Type</b></td><td><a href="https://snapwiki.miraheze.org/wiki/Block_Types#Command" title="Block Types">Command</a></td></tr></tbody></table><p><b>if on edge, bounce</b> is a <a href="https://snapwiki.miraheze.org/wiki/Command" class="mw-redirect" title="Command">command</a> block and a <a href="https://snapwiki.miraheze.org/wiki/Motion" title="Motion">motion</a> block. It first checks if the sprite is touching the edge, and if it is, the sprite "bounces" off the edge by turning the sprite away.</p><pre class="blocks">if on edge, bounce::motion
</pre><h2><span class="mw-headline" id="Example_Uses">Example Uses</span></h2><p>Bouncing a sprite around the <a href="https://snapwiki.miraheze.org/wiki/Stage" title="Stage">stage</a>:</p><pre class="blocks">when green flag clicked
go to x: (0) y: (0)
point in direction (45 v)
forever {
  move (2) steps
  if on edge, bounce
}
</pre><h2><span class="mw-headline" id="Definition">Definition</span></h2><p>This default definition can be found in <a href="https://snapwiki.miraheze.org/wiki/Snap!_10.0" title="Snap! 10.0">Snap<i>!</i> 10.0</a> with Blocks all the way on. Remove or delete the block immediately after the definition hat if you want the script to be in action.</p><p><br></p><pre class="blocks">{if touching edge, bounce&nbsp;:: motion}&nbsp;:: define+
&lt;t&gt; primitive [bounceOffEdge V]&nbsp;:: other
if &lt;touching [edge V]&nbsp;?&gt; {
  script variables ((get bounds)) ((bounds)) ((center)) ((stage bounds)) ((dir x)) ((dir y)) ((delta x)) ((delta y)) @delInput @addInput
  set [get bounds V] to ((list (minimum ((list (my [left V]) (my [bottom V]) @delInput @addInput) in front of (map ((list ([left V] of [ V]) ([bottom V] of [ V]) @delInput @addInput) @addInput) over (my [parts V])))) (maximum ((list (my [right V]) (my [top V]) @delInput @addInput) in front of (map ((list ([right V] of [ V]) ([top V] of [ V]) @delInput @addInput) @addInput) over (my [parts V])))) @delInput @addInput) @addInput)
  set [bounds V] to (call (get bounds) @verticalEllipsis @addInput)
  set [center V] to ((sum (bounds)) / (2))
  set [stage bounds V] to (ask (my [stage V]) for ((list (list (my [left V]) (my [bottom V]) @delInput @addInput) (list (my [right V]) (my [top V]) @delInput @addInput) @delInput @addInput) @addInput) @verticalEllipsis @addInput)
  set [dir x V] to ([sin V] of (direction))
  set [dir y V] to ([cos V] of (direction))
  if &lt;(item (1 v) of (item (1 v) of (bounds))) &lt; (item (1 v) of (item (1 v) of (stage bounds))) @delInput @verticalEllipsis @addInput&gt; {
    set [dir x V] to ([abs V] of (dir x))
  } @addInput
  if &lt;(item (1 v) of (item (2 v) of (bounds))) &gt; (item (1 v) of (item (2 v) of (stage bounds))) @delInput @verticalEllipsis @addInput&gt; {
    set [dir x V] to ([neg V] of ([abs V] of (dir x)))
  } @addInput
  if &lt;(item (2 v) of (item (2 v) of (bounds))) &gt; (item (2 v) of (item (2 v) of (stage bounds))) @delInput @verticalEllipsis @addInput&gt; {
    set [dir y V] to ([neg V] of ([abs V] of (dir y)))
  } @addInput
  if &lt;(item (2 v) of (item (1 v) of (bounds))) &lt; (item (2 v) of (item (1 v) of (stage bounds))) @delInput @verticalEllipsis @addInput&gt; {
    set [dir y V] to ([abs V] of (dir y))
  } @addInput
  point in direction (atan2 (dir x) / (dir y))
  set [bounds V] to (call (get bounds) @verticalEllipsis @addInput)
  go to ((position) + ((center) - ((sum (bounds)) / (2))) @delInput @verticalEllipsis @addInput)
  set [bounds V] to (call (get bounds) @verticalEllipsis @addInput)
  if &lt;(item (1 v) of (item (2 v) of (bounds))) &gt; (item (1 v) of (item (2 v) of (stage bounds))) @delInput @verticalEllipsis @addInput&gt; {
    set [delta x V] to ((item (1 v) of (item (2 v) of (stage bounds))) - (item (1 v) of (item (2 v) of (bounds))))
  } @addInput
  if &lt;(item (2 v) of (item (1 v) of (bounds))) &lt; (item (2 v) of (item (1 v) of (stage bounds))) @delInput @verticalEllipsis @addInput&gt; {
    set [delta y V] to ((item (2 v) of (item (1 v) of (stage bounds))) - (item (2 v) of (item (1 v) of (bounds))))
  } @addInput
  if &lt;(item (1 v) of (item (1 v) of (bounds))) &lt; (item (1 v) of (item (1 v) of (stage bounds))) @delInput @verticalEllipsis @addInput&gt; {
    set [delta x V] to ((item (1 v) of (item (1 v) of (stage bounds))) - (item (1 v) of (item (1 v) of (bounds))))
  } @addInput
  if &lt;(item (2 v) of (item (2 v) of (bounds))) &gt; (item (2 v) of (item (2 v) of (stage bounds))) @delInput @verticalEllipsis @addInput&gt; {
    set [delta y V] to ((item (2 v) of (item (2 v) of (stage bounds))) - (item (2 v) of (item (2 v) of (bounds))))
  } @addInput
  go to ((position) + (list (delta x) (delta y) @delInput @addInput) @delInput @verticalEllipsis @addInput)
} @addInput
</pre><h2><span class="mw-headline" id="See_Also">See Also</span></h2></div>