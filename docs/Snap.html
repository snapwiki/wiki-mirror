<div class="mw-pt-translate-header noprint nomobile" dir="ltr" lang="en"><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Translate&amp;group=page-Snap%21&amp;language=en&amp;action=page&amp;filter=" title="Special:Translate">Translate this page</a>; This page contains <span class="plainlinks"><a rel="nofollow" class="external text" href="https://snapwiki.miraheze.org/w/index.php?title=Snap!&amp;oldid=8248&amp;diff=10161">changes</a></span> which are not marked for translation.</div><div class="mw-parser-output"><div class="mw-pt-languages noprint" lang="en" dir="ltr"><div class="mw-pt-languages-label">Other languages:</div><div class="mw-pt-languages-list"><span class="mw-pt-languages-ui mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete" lang="en">English</span>&#160;• ‎<a href="https://snapwiki.miraheze.org/wiki/Snap!/bn" class="mw-pt-progress mw-pt-progress--stub" title="স্ন্যাপ! (16% translated)" lang="bn">বাংলা</a>&#160;• ‎<a href="https://snapwiki.miraheze.org/wiki/Snap!/zh-hans" class="mw-pt-progress mw-pt-progress--stub" title="Snap!/zh-hans (1% translated)" lang="zh-Hans">中文（简体）‎</a></div></div><table class="plainlinks metadata ambox ambox-notice" role="presentation"><tbody><tr><td class="mbox-image"><div style="width:52px"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1d/Information_icon4.svg/40px-Information_icon4.svg.png" decoding="async" width="40" height="40" srcset="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1d/Information_icon4.svg/60px-Information_icon4.svg.png 1.5x, https://upload.wikimedia.org/wikipedia/commons/thumb/1/1d/Information_icon4.svg/80px-Information_icon4.svg.png 2x" data-file-width="620" data-file-height="620"></div></td><td class="mbox-text"><div class="mbox-text-span">This page uses materials from <b>Scratch Wiki</b>'s page <b>Snap! (programming language)</b> which is licensed under <b>CC BY-SA 4.0</b>.</div></td></tr></tbody></table><p><b>Snap<i>!</i> (Build Your Own Blocks)</b> is an extended reimplementation of <a href="https://snapwiki.miraheze.org/wiki/Scratch" title="Scratch">Scratch</a> featuring first class procedures, first class lists, and first class sprites with inheritance. An earlier version, BYOB, was a <a href="https://en.wikipedia.org/wiki/Modification" class="extiw" title="wikipedia:Modification">modification</a> of the <a href="https://snapwiki.miraheze.org/wiki/Scratch" title="Scratch">Scratch</a> Version 1.4 source code, but the current version is an entirely separate program, even though its user interface looks like Scratch 1.4 and it includes almost all of its primitive blocks. BYOB was originally developed by Jens Mönig; as of BYOB 3.0, Brian Harvey joined as co-developer. (The code is still almost all written by Jens; Brian has contributed to the design, libraries, and documentation, as well as online mentoring of Snap<i>!</i> users.)</p><div style="display: inline-flex !important; border: 2px solid #bee5eb; border-radius: 0px; background: #d1ecf1; text-align: center; color: #0c5460 !important; min-width: 50%; width: auto !important; justify-content: space-between"><div style="display: flex; align-items: center; justify-content: space-between; width: 100px; align-self: center;"><div><span style="font-size: 3em;">ℹ️</span></div></div><div style="width: 10%"></div><div><p><b>Note</b><br><small>Scratch has been phenomenally successful at introducing young people to computer programming; part of that success has been the detailed, thoughtful design of each small piece of the language. In particular, they decided to <i>leave out</i> some features, to avoid confusing young users. The <b>tl;dr</b> explanation of Snap<i>!</i> is that it added those missing features. When the article says "In Scratch, it is not possible to..." please bear in mind that Snap<i>!</i> was designed to teach computer science courses to teenagers. A decision may be good for the Scratch target audience, but not for the Snap<i>!</i> target audience. In every case, the Scratch Team was aware of the possibilities that they decided to omit. Nothing in this article is meant to insult them.</small></p></div><div style="width: 100px;"></div></div><div class="center"><div class="floatnone"><a href="https://snapwiki.miraheze.org/wiki/File:Snap-shot.png" class="image" title="The Snap! interface."><img alt="The Snap! interface." src="https://static.miraheze.org/snapwikiwiki/thumb/7/73/Snap-shot.png/641px-Snap-shot.png" decoding="async" width="641" height="294" srcset="https://static.miraheze.org/snapwikiwiki/thumb/7/73/Snap-shot.png/962px-Snap-shot.png 1.5x, https://static.miraheze.org/snapwikiwiki/thumb/7/73/Snap-shot.png/1282px-Snap-shot.png 2x" data-file-width="1283" data-file-height="588"></a></div></div><p><br></p><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div><ul><li class="toclevel-1 tocsection-1"><a href="#Features"><span class="tocnumber">1</span> <span class="toctext">Features</span></a><ul><li class="toclevel-2 tocsection-2"><a href="#Build_Your_Own_Blocks_1.0_Features"><span class="tocnumber">1.1</span> <span class="toctext">Build Your Own Blocks 1.0 Features</span></a><ul><li class="toclevel-3 tocsection-3"><a href="#Custom_Blocks"><span class="tocnumber">1.1.1</span> <span class="toctext">Custom Blocks</span></a></li></ul></li><li class="toclevel-2 tocsection-4"><a href="#Build_Your_Own_Blocks_2.0_Features"><span class="tocnumber">1.2</span> <span class="toctext">Build Your Own Blocks 2.0 Features</span></a><ul><li class="toclevel-3 tocsection-5"><a href="#Nested_Sprites"><span class="tocnumber">1.2.1</span> <span class="toctext">Nested Sprites</span></a></li></ul></li><li class="toclevel-2 tocsection-6"><a href="#Build_Your_Own_Blocks_3.0_Features"><span class="tocnumber">1.3</span> <span class="toctext">Build Your Own Blocks 3.0 Features</span></a><ul><li class="toclevel-3 tocsection-7"><a href="#First_class_procedures"><span class="tocnumber">1.3.1</span> <span class="toctext"><b>First class procedures</b></span></a></li><li class="toclevel-3 tocsection-8"><a href="#First_class_lists"><span class="tocnumber">1.3.2</span> <span class="toctext"><b>First class lists</b></span></a></li><li class="toclevel-3 tocsection-9"><a href="#Minimal_footprint"><span class="tocnumber">1.3.3</span> <span class="toctext">Minimal footprint</span></a></li></ul></li><li class="toclevel-2 tocsection-10"><a href="#Build_Your_Own_Blocks_3.1_Features"><span class="tocnumber">1.4</span> <span class="toctext">Build Your Own Blocks 3.1 Features</span></a><ul><li class="toclevel-3 tocsection-11"><a href="#First_Class_Sprites_with_Inheritance"><span class="tocnumber">1.4.1</span> <span class="toctext"><b>First Class Sprites with Inheritance</b></span></a><ul><li class="toclevel-4 tocsection-12"><a href="#Prototyping_vs._Class/Instance_OOP"><span class="tocnumber">1.4.1.1</span> <span class="toctext">Prototyping vs. Class/Instance OOP</span></a></li><li class="toclevel-4 tocsection-13"><a href="#Details_in_BYOB_3.1_Inheritance_vs._Snap!_4.1"><span class="tocnumber">1.4.1.2</span> <span class="toctext">Details in BYOB 3.1 Inheritance vs. Snap<i>!</i> 4.1</span></a></li></ul></li></ul></li><li class="toclevel-2 tocsection-14"><a href="#Many_Other_Features"><span class="tocnumber">1.5</span> <span class="toctext">Many Other Features</span></a><ul><li class="toclevel-3 tocsection-15"><a href="#Generic_Hat_Block"><span class="tocnumber">1.5.1</span> <span class="toctext">Generic Hat Block</span></a></li><li class="toclevel-3 tocsection-16"><a href="#Zebra_Coloring"><span class="tocnumber">1.5.2</span> <span class="toctext">Zebra Coloring</span></a></li><li class="toclevel-3 tocsection-17"><a href="#Detailed_Mouse_Event_Hat_Block"><span class="tocnumber">1.5.3</span> <span class="toctext">Detailed Mouse Event Hat Block</span></a></li><li class="toclevel-3 tocsection-18"><a href="#Pause_and_Visual_Stepping"><span class="tocnumber">1.5.4</span> <span class="toctext">Pause and Visual Stepping</span></a></li><li class="toclevel-3 tocsection-19"><a href="#First_Class_Costumes_and_Pen_Trails"><span class="tocnumber">1.5.5</span> <span class="toctext">First Class Costumes and Pen Trails</span></a></li></ul></li></ul></li><li class="toclevel-1 tocsection-20"><a href="#Intellectual_Precursors"><span class="tocnumber">2</span> <span class="toctext">Intellectual Precursors</span></a><ul><li class="toclevel-2 tocsection-21"><a href="#Custom_Blocks_2"><span class="tocnumber">2.1</span> <span class="toctext">Custom Blocks</span></a></li><li class="toclevel-2 tocsection-22"><a href="#First_Class_Data"><span class="tocnumber">2.2</span> <span class="toctext">First Class Data</span></a></li><li class="toclevel-2 tocsection-23"><a href="#Prototyping"><span class="tocnumber">2.3</span> <span class="toctext">Prototyping</span></a></li></ul></li><li class="toclevel-1 tocsection-24"><a href="#History"><span class="tocnumber">3</span> <span class="toctext">History</span></a></li><li class="toclevel-1 tocsection-25"><a href="#Use_in_Scratch"><span class="tocnumber">4</span> <span class="toctext">Use in Scratch</span></a></li><li class="toclevel-1 tocsection-26"><a href="#Scratch_Mod_Design_Aesthetics"><span class="tocnumber">5</span> <span class="toctext">Scratch Mod Design Aesthetics</span></a></li><li class="toclevel-1 tocsection-27"><a href="#Alternative_Launch"><span class="tocnumber">6</span> <span class="toctext">Alternative Launch</span></a></li><li class="toclevel-1 tocsection-28"><a href="#External_Links"><span class="tocnumber">7</span> <span class="toctext">External Links</span></a></li></ul></div><h2><span class="mw-headline" id="Features">Features</span></h2><p>The main features added in Snap<i>!</i> are custom blocks (making user-created blocks), first-class procedures, first class lists, first class sprites with object inheritance, first-class costumes and sounds, and an enhanced user interface.</p><p>This article discusses only the most important features; consult the <a rel="nofollow" class="external text" href="https://snap.berkeley.edu/snapsource/help/SnapManual.pdf">Snap<i>!</i> Reference Manual</a> for a more canonical guide.</p><h3><span class="mw-headline" id="Build_Your_Own_Blocks_1.0_Features">Build Your Own Blocks 1.0 Features</span></h3><p>BYOB 1.0 was released on October 21, 2008. It was based on <a href="https://snapwiki.miraheze.org/wiki/Scratch_1.3" title="Scratch 1.3">Scratch 1.3</a>. Here is a figure from its documentation showing how a block can be made recursive.</p><p><a href="https://snapwiki.miraheze.org/wiki/File:BYOB1.png" class="image"><img alt="BYOB1.png" src="https://static.miraheze.org/snapwikiwiki/thumb/0/04/BYOB1.png/653px-BYOB1.png" decoding="async" width="653" height="391" srcset="https://static.miraheze.org/snapwikiwiki/thumb/0/04/BYOB1.png/980px-BYOB1.png 1.5x, https://static.miraheze.org/snapwikiwiki/0/04/BYOB1.png 2x" data-file-width="1236" data-file-height="740"></a></p><h4><span class="mw-headline" id="Custom_Blocks">Custom Blocks</span></h4><p>The ability to make custom blocks was the first goal of BYOB, as reflected in its name. A limited version of this capability, allowing only command blocks, later became part of <a href="https://snapwiki.miraheze.org/wiki/Scratch_2.0" title="Scratch 2.0">Scratch 2.0</a>. What is described here is the current form of this feature, which changed dramatically in BYOB3.</p><p>To begin making a block, use the button at the end of each palette, the semitransparent "+" sign at the top of the palette, or the "make a block" option when right-clicking on the scripting area background.</p><p><a href="https://snapwiki.miraheze.org/wiki/File:Make-button.png" class="image"><img alt="Make-button.png" src="https://static.miraheze.org/snapwikiwiki/0/00/Make-button.png" decoding="async" width="75" height="23" data-file-width="75" data-file-height="23"></a><a href="https://snapwiki.miraheze.org/wiki/File:Plus-sign.png" class="image"><img alt="Plus-sign.png" src="https://static.miraheze.org/snapwikiwiki/thumb/0/00/Plus-sign.png/202px-Plus-sign.png" decoding="async" width="202" height="121" srcset="https://static.miraheze.org/snapwikiwiki/thumb/0/00/Plus-sign.png/303px-Plus-sign.png 1.5x, https://static.miraheze.org/snapwikiwiki/0/00/Plus-sign.png 2x" data-file-width="404" data-file-height="242"></a><a href="https://snapwiki.miraheze.org/wiki/File:Context-menu.png" class="image"><img alt="Context-menu.png" src="https://static.miraheze.org/snapwikiwiki/thumb/a/a5/Context-menu.png/144px-Context-menu.png" decoding="async" width="144" height="103" srcset="https://static.miraheze.org/snapwikiwiki/thumb/a/a5/Context-menu.png/216px-Context-menu.png 1.5x, https://static.miraheze.org/snapwikiwiki/a/a5/Context-menu.png 2x" data-file-width="288" data-file-height="206"></a></p><div class="floatleft"><a href="https://snapwiki.miraheze.org/wiki/File:Block-dialog.png" class="image"><img alt="Block-dialog.png" src="https://static.miraheze.org/snapwikiwiki/thumb/4/41/Block-dialog.png/149px-Block-dialog.png" decoding="async" width="149" height="165" srcset="https://static.miraheze.org/snapwikiwiki/thumb/4/41/Block-dialog.png/224px-Block-dialog.png 1.5x, https://static.miraheze.org/snapwikiwiki/4/41/Block-dialog.png 2x" data-file-width="298" data-file-height="330"></a></div><p>In the dialog that appears, besides giving the block a name, the user can choose its palette category (color), its shape (command, reporter, or predicate), and whether it is for all sprites or just one.</p><p>Clicking OK opens a <i>block editor</i> window, essentially a separate scripting area just for this block definition. In the block editor, the user can add inputs to the block, and optionally set the type of an input, as well as adding the script that defines the block's actions. The use of a separate editor window is very different from the Scratch 2.0 design of custom blocks, in which all custom blocks are purple, sprite-local, and visible in the sprite's scripting area. The color isn't so important, but the idea behind it is: The Scratch design treats a custom block as something very different from a primitive block. The Snap<i>!</i> design tries to make custom blocks just as good as primitive blocks; ideally, once a block is written, it might as well be primitive. The fact that Scratch custom blocks are sprite-local is a result of the fact that their definitions have to appear in the scripting area of some particular sprite. Keeping the block definitions visible in the scripting area emphasizes that a custom block is essentially an abbreviation for a script, and ensures that all of the user's code is visible to the user. But keeping the definitions visible partly defeats the purpose of writing procedures, namely, to hide details and program at a higher level of abstraction.</p><p>Another difference is the treatment of inputs to a custom block. Inside the Scratch block definition, an input is represented by a purple oval containing the name of the input. These inputs are variables, but Scratch treats a procedure input as something very different from a (global) variable. In Snap<i>!</i>, the inputs are orange ovals, like other variables, and their values can be changed with <b>set</b> blocks. Also, procedures can have local variables that aren't inputs, using the <code class="blocks-2.0">script variables (a) @delInput @addInput&#160;::grey</code> block to create them. Like inputs, these script variables exist only inside the script. Every invocation of the block creates a separate set of script variables; this is particularly important when using <a href="https://snapwiki.miraheze.org/w/index.php?title=Recursion&amp;action=edit&amp;redlink=1" class="new" title="Recursion (page does not exist)">recursion</a>, avoiding the need for the user to construct an explicit <a href="https://snapwiki.miraheze.org/w/index.php?title=Stack&amp;action=edit&amp;redlink=1" class="new" title="Stack (page does not exist)">stack</a>.</p><h3><span class="mw-headline" id="Build_Your_Own_Blocks_2.0_Features">Build Your Own Blocks 2.0 Features</span></h3><p>BYOB 2.0 was released on August 30, 2009. It updated the underlying Scratch code to version 1.4 and added several UI improvements, including Undo.</p><h4><span class="mw-headline" id="Nested_Sprites">Nested Sprites</span></h4><p>A major feature added in BYOB 2.0 was the ability to make a collection of sprites that move together. The canonical example is a skeleton in which each bone is attached to one closer to the spine; the entire skeleton can rotate together, or a particular bone can rotate relative to the whole.</p><p><a href="https://snapwiki.miraheze.org/wiki/File:Swimmer.png" class="image"><img alt="Swimmer.png" src="https://static.miraheze.org/snapwikiwiki/thumb/5/5a/Swimmer.png/718px-Swimmer.png" decoding="async" width="718" height="199" srcset="https://static.miraheze.org/snapwikiwiki/5/5a/Swimmer.png 1.5x" data-file-width="1077" data-file-height="299"></a></p><h3><span class="mw-headline" id="Build_Your_Own_Blocks_3.0_Features">Build Your Own Blocks 3.0 Features</span></h3><p>BYOB3 was released <a href="https://scratcharchive.asun.co/forums/viewtopic.php?pid=375320#p375320" class="extiw" title="ar-post:375320">April 25, 2010</a>. It introduced first-class procedures and lists.</p><h4><span class="mw-headline" id="First_class_procedures"><b>First class procedures</b></span></h4><p><span style="display:inline-block;position:relative;left:25px;"><a href="https://snapwiki.miraheze.org/wiki/File:Command-ring.png" class="image"><img alt="Command-ring.png" src="https://static.miraheze.org/snapwikiwiki/thumb/d/da/Command-ring.png/58px-Command-ring.png" decoding="async" width="58" height="22" srcset="https://static.miraheze.org/snapwikiwiki/thumb/d/da/Command-ring.png/87px-Command-ring.png 1.5x, https://static.miraheze.org/snapwikiwiki/thumb/d/da/Command-ring.png/116px-Command-ring.png 2x" data-file-width="126" data-file-height="48"></a></span><span style="display:inline-block;position:relative;left:25px;"><a href="https://snapwiki.miraheze.org/wiki/File:Reporter_ring.png" class="image"><img alt="Reporter ring.png" src="https://static.miraheze.org/snapwikiwiki/thumb/7/7e/Reporter_ring.png/58px-Reporter_ring.png" decoding="async" width="58" height="23" srcset="https://static.miraheze.org/snapwikiwiki/thumb/7/7e/Reporter_ring.png/87px-Reporter_ring.png 1.5x, https://static.miraheze.org/snapwikiwiki/7/7e/Reporter_ring.png 2x" data-file-width="116" data-file-height="46"></a></span><span style="display:inline-block;position:relative;left:25px;"><a href="https://snapwiki.miraheze.org/wiki/File:Predicate_ring.png" class="image"><img alt="Predicate ring.png" src="https://static.miraheze.org/snapwikiwiki/thumb/3/38/Predicate_ring.png/58px-Predicate_ring.png" decoding="async" width="58" height="23" srcset="https://static.miraheze.org/snapwikiwiki/thumb/3/38/Predicate_ring.png/87px-Predicate_ring.png 1.5x, https://static.miraheze.org/snapwikiwiki/3/38/Predicate_ring.png 2x" data-file-width="116" data-file-height="46"></a></span></p><p>A data type is <i>first class</i> in a language if it can be used in all the same ways as any other data type. For example, in Scratch, it's easy to make a list of numbers, but a list of <i>lists</i> is impossible; numbers are first class, but lists aren't. One of the slogans of Snap<i>!</i> is "Everything first class." The biggest, most important difference between BYOB2 and BYOB3 was that the latter introduced first class procedures. The grey rings above are used to allow procedures (blocks and scripts) as data. A picture is worth 1000 words here:</p><div><span style="display:inline-block;position:relative;top:10px;"><a href="https://snapwiki.miraheze.org/wiki/File:2plus3.png" class="image"><img alt="2plus3.png" src="https://static.miraheze.org/snapwikiwiki/6/6f/2plus3.png" decoding="async" width="310" height="80" data-file-width="310" data-file-height="80"></a></span><span style="display:inline-block;position:relative;left:25px;"><a href="https://snapwiki.miraheze.org/wiki/File:2plus3ring.png" class="image"><img alt="2plus3ring.png" src="https://static.miraheze.org/snapwikiwiki/8/86/2plus3ring.png" decoding="async" width="606" height="114" data-file-width="606" data-file-height="114"></a></span></div><p>On the left, clicking the unringed 2+3 gives 5. On the right, putting 2+3 in a ring gives <i><b>the</b></i> <code class="blocks-2.0">((2) + (3))</code> <i><b>block itself.</b></i></p><table><tbody><tr><td><span><a href="https://snapwiki.miraheze.org/wiki/File:Call.png" class="image"><img alt="Call.png" src="https://static.miraheze.org/snapwikiwiki/6/60/Call.png" decoding="async" width="240" height="58" data-file-width="240" data-file-height="58"></a></span></td><td><span><a href="https://snapwiki.miraheze.org/wiki/File:Call2%2B3.png" class="image"><img alt="Call2+3.png" src="https://static.miraheze.org/snapwikiwiki/4/40/Call2%2B3.png" decoding="async" width="486" height="82" data-file-width="486" data-file-height="82"></a></span></td></tr></tbody></table><p>The only reason to create a ringed procedure is that later it will be called.</p><p>Users can create their own control structures, e.g., abstracting a repeated call of a function for each item of a list:</p><table><tbody><tr><td><span><a href="https://snapwiki.miraheze.org/wiki/File:Mapdef.png" class="image"><img alt="Mapdef.png" src="https://static.miraheze.org/snapwikiwiki/thumb/a/a9/Mapdef.png/325px-Mapdef.png" decoding="async" width="325" height="130" srcset="https://static.miraheze.org/snapwikiwiki/thumb/a/a9/Mapdef.png/488px-Mapdef.png 1.5x, https://static.miraheze.org/snapwikiwiki/a/a9/Mapdef.png 2x" data-file-width="650" data-file-height="260"></a></span></td><td><span style="display:inline-block;position:relative;top:23px;">➜</span></td><td><span style="display:inline-block;position:relative;top:23px;"><a href="https://snapwiki.miraheze.org/wiki/File:Mapblock.png" class="image"><img alt="Mapblock.png" src="https://static.miraheze.org/snapwikiwiki/thumb/9/94/Mapblock.png/94px-Mapblock.png" decoding="async" width="94" height="15" srcset="https://static.miraheze.org/snapwikiwiki/thumb/9/94/Mapblock.png/141px-Mapblock.png 1.5x, https://static.miraheze.org/snapwikiwiki/9/94/Mapblock.png 2x" data-file-width="188" data-file-height="29"></a></span></td><td><span style="display:inline-block;position:relative;top:23px;">➜</span></td><td><span><a href="https://snapwiki.miraheze.org/wiki/File:Mapcall.png" class="image"><img alt="Mapcall.png" src="https://static.miraheze.org/snapwikiwiki/thumb/5/51/Mapcall.png/261px-Mapcall.png" decoding="async" width="261" height="66" srcset="https://static.miraheze.org/snapwikiwiki/thumb/5/51/Mapcall.png/392px-Mapcall.png 1.5x, https://static.miraheze.org/snapwikiwiki/5/51/Mapcall.png 2x" data-file-width="522" data-file-height="132"></a></span></td></tr></tbody></table><p>Although making procedures first class was the most important change in BYOB3, it took Jens and bharvey three tries to get the notation right. One of the best things about Scratch is the careful design of each syntax element (e.g., C-shaped blocks) so that the underlying computer science idea (e.g., looping) is obvious to a Scratch learner just from seeing the visual presentation (e.g., the <code class="blocks-2.0">(:: control loop)</code> arrow at the bottom of a looping block).</p><p>In BYOB3, the representation for an encapsulated block, what's now the grey ring, was the clunky <code class="blocks-2.0">(the [] block&#160;:: operators)</code> for reporters, and <span style="display:inline-block;"><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=The_script.png" class="new" title="File:The script.png">82px</a></span> for commands. The current representation, the grey ring, was perfected by providing a grey ring <i>as the input slot</i> in blocks that expect a procedure as input, such as <b>call</b> and <b>map</b> above. As a result, users rarely have to deal explicitly with the rings. If one is needed, it's already there. Dragging a <i>ringed</i> block into an input slot with a ring "absorbs" the extra ring; dragging a <i>variable</i> into an input slot with a ring <i>removes</i> the ring since the meaning is almost always that the variable's <i>value</i> is the wanted expression to run.</p><p>When reading the <b>map</b> example above, was it immediately obvious that each list item is plugged into the empty slot in the <code class="blocks-2.0">(() + (3))</code> block? Elementary school teachers all know that if an eight-year-old is presented with "<i>x</i>+3=7" and asked "what's <i>x</i>?" they are likely to get a blank stare, but if the same kid is shown "☐+3=7" and ask "what number goes in the square?" they are likely to answer "four." Snap<i>!</i> uses that knowledge in the design of the notation for functions. When a grey-ringed function with input is called, <b>call</b> looks for an empty input slot inside the ring, and that's where the input value is inserted. This notation makes simple function calling obvious, in the Scratch spirit of trying to use the visual representation to make ideas obvious. The empty input slot mechanism is not good enough for the complicated cases, such as nesting a <b>map</b> call inside the function input to <i>another</i> <b>map</b> call. For those cases grey rings can be given explicit input names, just like a custom block: <code class="blocks-2.0">(((x::variables) + (3)) input names: (x::variables) @delInput @addInput&#160;:: grey ring)</code>.</p><p>In the computer science literature, the equivalent of a grey ring is a <i>lambda expression:</i> <b>λx. x+3</b>. "Lambda" (λ) is the Greek letter l. In Lisp, the programming language that brought lambda expressions to the attention of a wider range of programmers, they're written this way: <b>(lambda (x) (+ x 3))</b>. "Lambda" is spelled out because they didn't have Unicode back then, although at the Stanford and MIT Artificial Intelligence Labs they used special keyboards that did have λ keys.</p><h4><span class="mw-headline" id="First_class_lists"><b>First class lists</b></span></h4><p>Adding lambda to Scratch made it possible to invent any <i>control</i> structure; the other big problem with Scratch is that lists can't be items of other lists, so it is not possible to straightforwardly build complex <i>data</i> structures. In Scratch, a list is, sort of, a kind of variable: It has a name and a value, just like a variable, but the value has sub-values (the items). Scratch provides a red oval for the list, like the orange one for a variable, but the value it reports isn't the actual list; it's a concatenation of all the items, separated by spaces. This works because only strings and numbers can be items in a list.</p><p>Scratch lists combine two logically separate capabilities. The main capability of a list is that it can add, change, delete, and report items. The second capability is associating a name with the list, and that should instead be the job of a variable. If a user wants a list with items "Yakko," "Wakko," and "Dot," and wants to call the list "Animaniacs," it should be possible to say <code class="blocks-2.0">set [Animaniacs v] to (list [Yakko] [Wakko] [Dot] @delInput @addInput:: list)</code>.</p><p>The <b>list</b> block is the only completely new capability needed to support lists as first-class data. The existing Scratch list blocks do everything else that's needed, but since names are no longer necessarily associated with lists, the dropdown list-name inputs in the Scratch list blocks are replaced with list-type input slots: <a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Listblock.png" class="new" title="File:Listblock.png">File:Listblock.png</a>. The white rectangle with thick orange lines inside is meant to look like a list watcher, with orange items.</p><h4><span class="mw-headline" id="Minimal_footprint">Minimal footprint</span></h4><p>When BYOB3 was released in 2010, its developers still hoped that the Scratch Team would be persuaded to add its features to Scratch itself. The design therefore minimized the number of new blocks added, creating new user interface features such as variable-arity blocks that might otherwise have been multiple blocks: <code class="blocks-2.0">(call (() @addInput&#160;:: grey ring) @addInput::control)</code> versus <code class="blocks-2.0">(call (() @addInput&#160;:: grey ring) with inputs: [] @delInput @addInput::control)</code> versus <code class="blocks-2.0">(call (() @addInput&#160;:: grey ring) input list: (list [input1] [input2] ...::list)&#160;::control)</code>.<br>In the end, only seven blocks and one button were needed:</p><div class="center"><div class="floatnone"><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Just8.jpg" class="new" title="File:Just8.jpg">File:Just8.jpg</a></div></div><p>(<b>Run</b> and <b>launch</b> are the equivalent to <b>call</b> for scripts of command blocks; <b>run</b> is like <b>broadcast and wait</b> while <b>launch</b> is like <b>broadcast</b>, not waiting for the launched script to finish. <b>Report</b> is what a custom reporter or predicate uses to report a value to its caller.)</p><p>BYOB 3.0 actually had a few more blocks, just for convenience, not related to these core features. For example, the <code class="blocks-2.0">&lt;true::operators&gt;</code> and <code class="blocks-2.0">&lt;false::operators&gt;</code> Boolean value reporters were added, to avoid some ad hoc idioms in Scratch programs that needed Boolean constants.</p><h3><span class="mw-headline" id="Build_Your_Own_Blocks_3.1_Features">Build Your Own Blocks 3.1 Features</span></h3><p>First-class sprites and prototype-style inheritance were the main changes in BYOB 3.1, officially released May 18, 2011, but with development versions available online for several months before the official release.</p><h4><span class="mw-headline" id="First_Class_Sprites_with_Inheritance"><b>First Class Sprites with Inheritance</b></span></h4><p><a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Object-oriented_programming">Object-oriented programming</a> is a style based around the abstraction <i>object:</i> a collection of data and methods (procedures, which in Snap<i>!</i> are just more data) that is interacted with by sending it a message (just a name, maybe in the form of a text string, and perhaps additional inputs). The object responds to the message by carrying out a method, which may or may not report a value back to the asker. Some people emphasize the <i>data hiding</i> aspect of OOP (because each object has local variables that other objects can access only by sending request messages to the owning object) while others emphasize the <i>simulation</i> aspect (in which each object abstractly represents something in the world and the interactions of objects in the program model real interactions of real people or things). Data hiding is important for large multi-programmer industrial projects, but for Snap<i>!</i> users it’s the simulation aspect that’s important. The Snap<i>!</i> approach is, therefore, less restrictive than that of some other OOP languages; objects are given easy access to each others’ data and methods.</p><p>Scratch provides a very natural set of objects, namely, <a href="https://snapwiki.miraheze.org/w/index.php?title=Sprites&amp;action=edit&amp;redlink=1" class="new" title="Sprites (page does not exist)">sprites</a>. Object-oriented programming rests on three legs:</p><ol><li><b>Persistent local state.</b> An object must be able to remember its history from one action to the next, in variables whose names are private to that object. Scratch sprites have this, in the form of "for this sprite only" variables.</li><li><b>Message passing.</b> One object has to be able to ask another object to do something, by sending it a message. Scratch doesn't exactly have this capability, but a sprite can <a href="https://snapwiki.miraheze.org/w/index.php?title=Broadcast&amp;action=edit&amp;redlink=1" class="new" title="Broadcast (page does not exist)">broadcast</a> a message to <i>all</i> sprites. Snap<i>!</i> adds true message passing, in which the messages take the form of blocks or scripts, which are carried out using the local blocks and variables of the receiver.</li><li><b>Inheritance.</b> It's very common for two or more objects to share some methods (local procedures). Object-oriented programming would be hopelessly complicated if the methods had to be duplicated by hand in each object. So object-oriented languages provide a way for one object to <i>inherit</i> methods and data from another. Starting in <a href="https://snapwiki.miraheze.org/wiki/Scratch_2.0" title="Scratch 2.0">Scratch 2.0</a>, there is a restricted form of inheritance: It's possible to <a href="https://snapwiki.miraheze.org/w/index.php?title=Clone&amp;action=edit&amp;redlink=1" class="new" title="Clone (page does not exist)">clone</a> a sprite; the resulting sprite is a <i>copy</i> of the original, and is temporary; when the program stops running, the temporary clones are deleted. Temporary clones are good for things like the bricks in a Breakout game; they all have the same behavior, just different positions, and can be recreated at the start of each new game. But sometimes a project needs permanent clones; one example would be the four ghosts in a Pacman game, each of which has slightly different behavior. Snap<i>!</i> provides both kinds of cloning: Clones created in a program, using the <code class="blocks-2.0">create a clone of [ v]::control</code> block or, since sprites are first-class data in Snap<i>!</i>, the new <code class="blocks-2.0">(a new clone of [myself v]::control)</code> reporter, are temporary. Clones created from the user interface, e.g., by right-clicking on a sprite icon in the sprite corral and choosing the "clone" option from the context menu, are permanent; they appear in the sprite corral, are independently editable, and are saved with the project.</li></ol><p>A clone is <i>not</i> a copy of its parent; it shares the attributes of the parent. So, for example, if a costume of the parent is deleted, it's gone in the child also. However, if something is changed <i>in the child,</i> then the connection of that attribute with the parent is broken, and the child has a separate one of whatever it is. If the child imports a new costume, its entire wardrobe (the list of all its costumes) is copied from the parent, then the new costume is added, and thereafter the two sprites are independent concerning costumes.</p><p>It could be confusing if a child shares some attributes of its parent but not others. To avoid confusion, attributes represented by palette blocks are <i><b>ghosted</b></i> in the child's palette and variable watchers:</p><table><tbody><tr><td><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Methods.png" class="new" title="File:Methods.png">130px</a></td><td><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Vars.png" class="new" title="File:Vars.png">130px</a></td><td><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Watchers.png" class="new" title="File:Watchers.png">190px</a></td><td><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Xypos.png" class="new" title="File:Xypos.png">75px</a></td><td><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Xywatch.png" class="new" title="File:Xywatch.png">200px</a></td></tr></tbody></table><p>A child breaks an attribute's inheritance from its parent by changing its value. If the child's position is inherited, <code class="blocks-2.0">move ( ) steps</code> will break the inheritance of both x and y position. But <code class="blocks-2.0">set x to ( )</code> will break the inheritance of the x position, leaving the inheritance of the y position intact.</p><p>What if a child has broken the inheritance of some attribute and now wants to restore inheriting that attribute from its parent? A new block <code class="blocks-2.0">inherit [x position v]::variables</code> allows that. The dropdown menu includes the standard sprite attributes, but variables and other attribute blocks can be dropped on the menu input slot if enclosed in a ring: <code class="blocks-2.0">inherit ((var::variables) @addInput&#160;:: grey ring)::variables</code> <code class="blocks-2.0">inherit ((x position) @addInput&#160;:: grey ring)::variables</code>.</p><h5><span id="Prototyping_vs._Class.2FInstance_OOP"></span><span class="mw-headline" id="Prototyping_vs._Class/Instance_OOP">Prototyping vs. Class/Instance OOP</span></h5><p>Readers who have programmed in class/instance languages may feel that what's described here isn't OOP. But classes aren't necessary and are harmful in a dynamic, interpreted language that encourages tinkering. Class/instance programmers typically design their entire class hierarchy before actually writing code. That's an appropriate discipline for a large group of programmers working on the same program, but not for one kid designing a project on the fly. What the kid wants to do is build, for example, a dog sprite, and program it with behaviors similar to those of his or her pet cocker spaniel. <i>Then</i> the kid decides to add a Rottweiler to the project. It should inherit most of the behaviors of the cocker spaniel, but with a few differences. This OOP structure is called <i>prototyping</i> or <i>prototype-based OOP.</i></p><p>If classes are necessary, make a sprite, give it children, then <code class="blocks-2.0">hide</code> the parent. The parent is then effectively a class.</p><p>Another way in which this OOP design is nontraditional is that it uses blocks (procedures) as messages, and <i>any</i> block can be used, not just the ones that the receiver has declared as public methods. As explained earlier, in the Snap<i>!</i> design, data hiding is less important than simulation, the use of objects as metaphors for some real system of agents.</p><table cellpadding="10" cellspacing="0" border="2"><tbody><tr><td>Note: OOP does not require a special OOP language. If a language has first-class procedures and lexical scope, then it's possible to build an object system in the language. See the Snap<i>!</i> Reference Manual for details.</td></tr></tbody></table><h5><span id="Details_in_BYOB_3.1_Inheritance_vs._Snap.21_4.1"></span><span class="mw-headline" id="Details_in_BYOB_3.1_Inheritance_vs._Snap!_4.1">Details in BYOB 3.1 Inheritance vs. Snap<i>!</i> 4.1</span></h5><p>Version 3.1 predated Scratch 2.0, so it didn't include Scratch-style temporary clones; all clones, whether made in the GUI or a program, were permanent (until explicitly deleted). Also, the developers thought that users would most likely want to inherit certain sprite attributes and not others, and tried to guess which were which. Experience later showed that users found it easier to understand if <i>all</i> attributes were initially inherited, especially since assigning a new value to the child's attribute breaks the inheritance, probably just what the user wants.</p><h3><span class="mw-headline" id="Many_Other_Features">Many Other Features</span></h3><p>Each release added dozens of features not discussed here, because they don't rise to the level of importance of custom blocks, first-class procedures, first class lists, first class sprites, and first-class continuations. Here is a representative sample:</p><h4><span class="mw-headline" id="Generic_Hat_Block">Generic Hat Block</span></h4><p><code class="blocks">when &lt;&gt;&#160;:: hat control</code></p><p>Custom hat blocks have been a frequent user request since the early days of custom blocks. The <i>generic when</i> block, introduced in 4.0, answers that need. The feature required particularly careful design, because the script is in a sense always running an implicit <code class="blocks">forever if &lt;&gt;&#160;:: control</code>, so it could slow down projects using it, even if the user tries to stop all scripts. To avoid this problem, generic hat blocks, unlike all other hat blocks, are disabled by the red stop button or by a <code class="blocks">stop [all v]</code> block. Some other script must run, either because an event triggers its hat block or because the user clicks it, to re-enable generic hat blocks.</p><h4><span class="mw-headline" id="Zebra_Coloring">Zebra Coloring</span></h4><div class="thumb tright"><div class="thumbinner" style="width:234px;"><a href="https://snapwiki.miraheze.org/wiki/File:Zebra_mussel_icon.png" class="image"><img alt="Zebra mussel icon.png" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/Zebra_mussel_icon.png/232px-Zebra_mussel_icon.png" decoding="async" width="232" height="231" class="thumbimage" srcset="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/Zebra_mussel_icon.png/348px-Zebra_mussel_icon.png 1.5x, https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/Zebra_mussel_icon.png/464px-Zebra_mussel_icon.png 2x" data-file-width="1538" data-file-height="1530"></a><div class="thumbcaption"><div class="magnify"><a href="https://snapwiki.miraheze.org/wiki/File:Zebra_mussel_icon.png" class="internal" title="Enlarge"></a></div></div></div></div><p>This feature, introduced in BYOB 3.0, is representative of the careful attention to the user interface in BYOB/Snap<i>!</i>. When same-color blocks are nested, it's hard to see the borders between them. Zebra coloring assigns <i>two</i> colors to each palette category, the normal color and a lighter color. When same-color blocks are nested, the outermost one has the normal color, and an inner block takes the opposite color from the one just outside it. The text inside light color blocks is black, instead of white as usual.</p><h4><span class="mw-headline" id="Detailed_Mouse_Event_Hat_Block">Detailed Mouse Event Hat Block</span></h4><p><a href="https://snapwiki.miraheze.org/wiki/Special:FilePath/Mouse-block.png" title="Special:FilePath/Mouse-block.png"><img alt="Mouse-block.png" src="https://static.miraheze.org/snapwikiwiki/b/ba/Mouse-block.png" decoding="async" width="298" height="205" data-file-width="298" data-file-height="205"></a></p><p>Since 4.1, users can detect all mouse events, not just clicks. (The "stopped" option was added in 4.2, to allow physical robot packages to detect clicking the stop button and stop the robot's motors. To prevent runaway scripts, a "when I am stopped" script is allowed to run for only one display cycle.)</p><h4><span class="mw-headline" id="Pause_and_Visual_Stepping">Pause and <a href="https://snapwiki.miraheze.org/wiki/Visible_Stepping" title="Visible Stepping">Visual Stepping</a></span></h4><p><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Control-buttons.png" class="new" title="File:Control-buttons.png">345px</a></p><p>Since 3.0, the menu bar has included a <i>pause</i> button, between the green flag and the stop sign. Clicking the button pauses the thread scheduler and replaces the "pause" icon with a yellow "play" icon. Clicking again continues running the project. There is also a <code class="blocks">pause all ❚❚&#160;:: control</code> block that can be inserted in a script to set a breakpoint while debugging.</p><p>Since 4.0, the <i>visual stepping</i> feature from Scratch 1.4 (in which it's misleadingly named <a href="https://snapwiki.miraheze.org/wiki/Single_Stepping" title="Single Stepping">Single Stepping</a>) is controlled by a menu bar button (with the feet icon), and a slider that appears when the button is clicked that controls the speed. If the slider is all the way to the left, true <i>single stepping</i> is used: the pause button must be clicked for each step. If a custom block is edited after enabling visual stepping, then the stepping includes the blocks inside that edit window. (More than one editor can be opened.)</p><h4><span class="mw-headline" id="First_Class_Costumes_and_Pen_Trails">First Class Costumes and Pen Trails</span></h4><p>Since 4.1 there is a <code class="blocks">(pen trails::pen)</code> block that reports everything currently drawn or stamped on the stage as a costume. Since costumes are first class data, this block can be used as input to any block, e.g., <code class="blocks">add (pen trails::pen) to (my costumes::variables)::list)</code>, <code class="blocks">switch to costume (pen trails::pen)::looks</code>, or <code class="blocks">say (pen trails::pen) for (2) secs::looks</code>.</p><h2><span class="mw-headline" id="Intellectual_Precursors">Intellectual Precursors</span></h2><h3><span class="mw-headline" id="Custom_Blocks_2">Custom Blocks</span></h3><p>The ability to write and invoke procedures, which is the core idea of Build Your Own Blocks, has been part of almost every programming language (with hardware support in every processor design at least to the extent of an instruction to save the return address somewhere before jumping to the procedure) in the history of computing. (In the original Fortran, the first general-purpose high level programming language, procedures were not reentrant, like Scratch scripts, which break off in the middle if the event that started the script happens again.)</p><p><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Mapwithexample.png" class="new" title="File:Mapwithexample.png">File:Mapwithexample.png</a></p><p><a href="https://snapwiki.miraheze.org/w/index.php?title=Special:Upload&amp;wpDestFile=Glide_BYOB.png" class="new" title="File:Glide BYOB.png">File:Glide BYOB.png</a></p><p>Among languages intended primarily for children, there were heated debates between BASIC and <a href="https://en.wikipedia.org/wiki/Logo_(programming_language)" class="extiw" title="wikipedia:Logo (programming language)">Logo</a> advocates because the latter included support for recursive procedures and the former did not, limiting itself instead to something pretty similar to the Scratch <a href="https://snapwiki.miraheze.org/w/index.php?title=Broadcast_()_and_Wait_(block)&amp;action=edit&amp;redlink=1" class="new" title="Broadcast () and Wait (block) (page does not exist)">Broadcast () and Wait</a> block. There's an irony in this, since the Scratch Team is a descendant of the old MIT Logo Lab. <a href="https://en.wikipedia.org/wiki/Seymour_Papert" class="extiw" title="wikipedia:Seymour Papert">Seymour Papert</a>, one of Logo's inventors and the founder of the MIT Logo Lab, argued for recursion as one of the mathematical big ideas that children should learn from programming computers.</p><h3><span class="mw-headline" id="First_Class_Data">First Class Data</span></h3><p>The phrase "<a href="https://en.wikipedia.org/wiki/First-class_object" class="extiw" title="wikipedia:First-class object">first class data</a>" was coined by computer scientist <a href="https://en.wikipedia.org/wiki/Christopher_Strachey" class="extiw" title="wikipedia:Christopher Strachey">Christopher Strachey</a>, who argued in the 1960s that any data type that exists in a language at all should be first class. This means that data of that type</p><ul><li>can be the value of a variable.</li><li>can be an input to a procedure (Scratch: block).</li><li>can be reported by a procedure.</li><li>can be a member of an aggregate (Scratch: list).</li><li>can exist without having a name.</li></ul><p>It's easy to see why one might want lists of lists; every data structure (trees, heaps, hash tables, etc.) can be constructed out of lists, but not straightforwardly with only lists of text strings. But why should procedures be first class? This was historically a counterintuitive idea, especially because a procedure can not be recursive unless it has a name by which to call itself.</p><p>The idea of first class procedures comes ultimately from the 1936 invention by mathematician <a href="https://en.wikipedia.org/wiki/Alonzo_Church" class="extiw" title="wikipedia:Alonzo Church">Alonzo Church</a> of <a href="https://en.wikipedia.org/wiki/lambda_calculus" class="extiw" title="wikipedia:lambda calculus">lambda calculus</a>, which is a formal study of the behavior of functions. In 1936 there were only a handful of experimental computers, and no symbolic programming languages, so the fact that lambda calculus turned out to be of practical use (it is the basis for much of the theory of programming languages today) was a great confirmation of the power of the idea.</p><p>Church demonstrated that the ability to create and call functions is <i>universal</i> &#8212; it is all that is needed to perform any computation that can be done at all. (He also proved that there are undecidable problems, which is the reason for the qualifying clause above.) In BYOB terms, this means a programming language with nothing but THE BLOCK and CALL could exist, and still be able to compute any function. (See <a rel="nofollow" class="external text" href="http://byob.berkeley.edu/Church.pdf">this BYOB project description</a> for an explanation of how to invent arithmetic from that starting point.) The Greek letter lambda (&#955;) is Church's name for a gray ring.</p><p><a href="https://snapwiki.miraheze.org/wiki/Special:FilePath/Compose.png" title="Special:FilePath/Compose.png"><img alt="Compose.png" src="https://static.miraheze.org/snapwikiwiki/4/46/Compose.png" decoding="async" width="410" height="85" data-file-width="410" data-file-height="85"></a></p><p>(Of course lambda does not solve the problem of input/output: capturing mouse clicks, drawing pictures on the screen, and so on. Although obviously of crucial practical importance, such input/output activities are not central to the understanding of what a program or a programming language is.)</p><p>Church's work influenced actual programming language design by way of <a href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)" class="extiw" title="wikipedia:John McCarthy (computer scientist)">John McCarthy</a>'s 1958 invention of the <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" class="extiw" title="wikipedia:Lisp (programming language)">Lisp</a> programming language for artificial intelligence research. Lisp is a direct influence on Logo, and therefore an indirect influence on Scratch. The detailed design of first class procedures in Build Your Own Blocks was strongly influenced by <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)" class="extiw" title="wikipedia:Scheme (programming language)">Scheme</a>, a Lisp dialect invented in the late 1970s by <a href="https://en.wikipedia.org/wiki/Gerald_Jay_Sussman" class="extiw" title="wikipedia:Gerald Jay Sussman">Gerald Jay Sussman</a> and <a href="https://en.wikipedia.org/wiki/Guy_L._Steele" class="extiw" title="wikipedia:Guy L. Steele">Guy Steele</a>, which brought Lisp closer to its roots in lambda calculus by introducing lexical scoping rules.</p><h3><span class="mw-headline" id="Prototyping">Prototyping</span></h3><p>The <b>clone</b> block reports a new object that inherits properties of the parent object. This allows users to create an object hierarchy, as in other OOP languages such as Smalltalk. But unlike Smalltalk, Build Your Own Blocks does not distinguish between classes and instances; every object can be viewed as an instance of its parent or as the class of its children. This form of inheritance is called "prototyping" because the user builds an <i>example</i> of a category of sprite rather than building the category as an abstract description. The best known prototyping languages are JavaScript and <a href="https://en.wikipedia.org/wiki/Self_(programming_language)" class="extiw" title="wikipedia:Self (programming language)">Self</a>. The particular form of prototyping used in BYOB was inspired by the work of <a rel="nofollow" class="external text" href="http://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html">Henry Lieberman</a>.</p><h2><span class="mw-headline" id="History">History</span></h2><div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="https://snapwiki.miraheze.org/wiki/Special:FilePath/BYOB_certificate.png" title="Special:FilePath/BYOB certificate.png"><img alt="" src="https://static.miraheze.org/snapwikiwiki/thumb/7/70/BYOB_certificate.png/300px-BYOB_certificate.png" decoding="async" width="300" height="225" class="thumbimage" srcset="https://static.miraheze.org/snapwikiwiki/thumb/7/70/BYOB_certificate.png/450px-BYOB_certificate.png 1.5x, https://static.miraheze.org/snapwikiwiki/thumb/7/70/BYOB_certificate.png/600px-BYOB_certificate.png 2x" data-file-width="960" data-file-height="720"></a><div class="thumbcaption"><div class="magnify"><a href="https://snapwiki.miraheze.org/wiki/File:BYOB_certificate.png" class="internal" title="Enlarge"></a></div>The certificate.</div></div></div><p>Jens' first modification was <a href="https://snapwiki.miraheze.org/wiki/Chirp_(Scratch_modification)" title="Chirp (Scratch modification)">Chirp</a>, a program that had improvements to Scratch. He then began to work on Build Your Own Blocks (a much bigger project), which has three versions: 1.0 (based on Scratch 1.3), 2.0 (based on Scratch 1.4), and version 3.1.1, which can be downloaded <a rel="nofollow" class="external text" href="https://snap.berkeley.edu/old-byob.html">here</a>. Bharvey put a "Certificate of Appreciation" on the BYOB website, consisting of 16 people who helped test the alpha versions of BYOB3.</p><p>In 2009, the University of California at Berkeley decided to create a new computer science course for non-majors and wanted to use Scratch as the programming language, but also wanted to teach recursion and higher order functions. This is how bharvey, one of the developers of the new course, joined the BYOB project, working with Jens to design the user interface for first class lists and first class procedures.</p><p>Snap<i>!</i> 4 is written in <a href="https://en.wikipedia.org/wiki/JavaScript" class="extiw" title="wikipedia:JavaScript">JavaScript</a>, using the HTML5 <a href="https://en.wikipedia.org/wiki/Canvas_element" class="extiw" title="wikipedia:Canvas element">canvas element</a>. It uses a <a href="https://snapwiki.miraheze.org/wiki/Morphic" class="mw-redirect" title="Morphic">Morphic</a> library by Jens called Morphic.js.</p><p>The current Snap<i>!</i> 4.2 version can be found <a rel="nofollow" class="external text" href="http://snap.berkeley.edu/run">here</a> to try out.</p><p>The Build Your Own Blocks-based <a rel="nofollow" class="external text" href="http://bjc.berkeley.edu">Beauty and Joy of Computing</a> curriculum has been converted to Snap<i>!</i>.</p><h2><span class="mw-headline" id="Use_in_Scratch">Use in Scratch</span></h2><p>The <a href="https://snapwiki.miraheze.org/wiki/Scratch_Team" title="Scratch Team">Scratch Team</a> has incorporated a function based on Build Your Own Blocks into <a href="https://snapwiki.miraheze.org/wiki/Scratch" title="Scratch">Scratch</a> 2.0. Custom blocks are procedures (also known as functions or methods) in which a script can easily be modified or run without duplicating it entirely. An example of Scratch's custom block is below:</p><pre class="blocks">

define jump
repeat (10)
change y by (6)
end
repeat (10)
change y by (-6)
end

jump

</pre><h2><span class="mw-headline" id="Scratch_Mod_Design_Aesthetics">Scratch Mod Design Aesthetics</span></h2><p>It is traditional to measure the power of a Scratch modification in part by the number of blocks it adds to the language. BYOB/Snap<i>!</i> has taken the opposite approach, trying to get a lot of expressive power out of a very small number of new blocks.</p><p>One reason for this is that an explicit goal of Build Your Own Blocks was to influence the design of Scratch 2.0, and it was hoped that the Scratch Team might be more amenable to changes with a "small footprint" ones that will not intrude dramatically on the experience of the traditional Scratch programmer.</p><h2><span class="mw-headline" id="Alternative_Launch">Alternative Launch</span></h2><div class="thumb tleft"><div class="thumbinner" style="width:202px;"><a href="https://snapwiki.miraheze.org/wiki/File:Snap!.png" class="image"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Snap%21.png/200px-Snap%21.png" decoding="async" width="200" height="110" class="thumbimage" srcset="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Snap%21.png/300px-Snap%21.png 1.5x, https://upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Snap%21.png/400px-Snap%21.png 2x" data-file-width="1187" data-file-height="652"></a><div class="thumbcaption"><div class="magnify"><a href="https://snapwiki.miraheze.org/wiki/File:Snap!.png" class="internal" title="Enlarge"></a></div>The alternative launcher in action</div></div></div>One other way that is used for launching Snap! in the offline editor is BirdBrain Robot Server can be used to launch Snap! And further using it's glory. It does require a download, and when opening the application a prompt is given to launch Snap<i>!</i>.<h2><span class="mw-headline" id="External_Links">External Links</span></h2><ul><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20120118181423/http://www.chirp.scratchr.org/blog/?p=19">Announcement of BYOB1 on Jens's blog</a></li><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20120303073758/http://www.chirp.scratchr.org/blog/?p=25">Announcement of BYOB2 on Jens's blog</a></li><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20120303073849/http://www.chirp.scratchr.org/blog/?p=32">Announcement of BYOB3 on Jens's blog</a></li><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20120406145130/http://www.chirp.scratchr.org:80/blog/?p=37">Announcement of BYOB3.1 on Jens's blog</a></li><li><a href="https://scratcharchive.asun.co/forums/viewtopic.php?id=10887" class="extiw" title="ar-topic:10887">BYOB Forum Topic</a></li><li><a href="https://scratcharchive.asun.co/forums/viewtopic.php?id=34284" class="extiw" title="ar-topic:34284">BYOB 3 Forum Topic</a></li><li><a rel="nofollow" class="external text" href="https://scratch.mit.edu/discuss/topic/4455">Snap<i>!</i> Forum Topic on the Scratch Discussion Forums</a></li><li><a rel="nofollow" class="external text" href="https://web.archive.org/web/20110728010457/http://chirp.scratchr.org/dl/BYOB.PDF">BYOB1 manual</a></li><li><a href="https://snap.berkeley.edu/BYOBManual.pdf" class="extiw" title="snap:BYOBManual.pdf">BYOB 3.1.1 Reference Manual</a></li><li><a href="https://snap.berkeley.edu/snap/help/SnapManual.pdf" class="extiw" title="snap:snap/help/SnapManual.pdf">Snap<i>!</i> Reference Manual</a></li><li><a href="https://snap.berkeley.edu/" class="extiw" title="snap:">Snap<i>!</i> Website</a></li><li><a href="https://en.wikipedia.org/wiki/Snap!_(programming_language)" class="extiw" title="wikipedia:Snap! (programming language)">Snap<i>!</i> on Wikipedia</a></li></ul></div>