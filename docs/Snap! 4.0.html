<!DOCTYPE html><html prefix="dc: http://purl.org/dc/terms/ mw: http://mediawiki.org/rdf/" about="https://snapwiki.miraheze.org/wiki/Special:Redirect/revision/10166"><head prefix="mwr: https://snapwiki.miraheze.org/wiki/Special:Redirect/"><meta charset="utf-8"><meta property="mw:pageId" content="339"><meta property="mw:pageNamespace" content="0"><link rel="dc:replaces" resource="mwr:revision/10165"><meta property="mw:revisionSHA1" content="2e75c3ed9830b6f47413f51b4b6a39dad781314a"><meta property="dc:modified" content="2021-08-30T17:45:45.000Z"><meta property="mw:html:version" content="2.2.0"><link rel="dc:isVersionOf" href="https://snapwiki.miraheze.org/wiki/Snap!_4.0"><title>Snap! 4.0</title><base href="https://snapwiki.miraheze.org/wiki/"><link rel="stylesheet" href="/w/load.php?lang=en&amp;modules=mediawiki.skinning.content.parsoid%7Cmediawiki.skinning.interface%7Csite.styles&amp;only=styles&amp;skin=vector"><meta http-equiv="content-language" content="en"><meta http-equiv="vary" content="Accept"></head><body data-parsoid='{"dsr":[0,18050,0,0]}' lang="en" class="mw-content-ltr sitedir-ltr ltr mw-body-content parsoid-body mediawiki mw-parser-output" dir="ltr"><section data-mw-section-id="0" data-parsoid="{}"><p data-parsoid='{"dsr":[0,426,0,0]}'>Snap<i data-parsoid='{"dsr":[4,9,2,2]}'>!</i> 4.0, released on May 1st, 2015, was a full rewrite &amp; overhaul of the BYOB Scratch modification in Javascript. BYOB 3.1.1 was slow, buggy, based on the aging Scratch 1.4 codebase, and could not be run in a web browser - because of this, the decision was made to rewrite it from the ground up using HTML5 and Javascript. Development started in 2011, about the same time that the Scratch Team began work on Scratch 2.0.</p><p data-parsoid='{"dsr":[428,1121,0,0]}'>Snap<i data-parsoid='{"dsr":[432,437,2,2]}'>!</i> 4.0 was built on and along with the <a rel="mw:WikiLink" href="./Morphic.js" title="Morphic.js" data-parsoid='{"stx":"simple","a":{"href":"./Morphic.js"},"sa":{"href":"Morphic.js"},"dsr":[474,488,2,2]}'>Morphic.js</a> framework, an effort to replicate Squeak Smalltalk's Morphic graphical environment using HTML5 canvas elements, while Scratch 2.0 was written in Adobe Flash. Flash was quickly becoming obsolete, being replaced with more secure technologies, but it allowed Scratch to interface with the user's camera and microphone, and to play a variety of MIDI instruments. The Scratch Team felt that these were necessary to encourage creativity in a younger audience. On the other hand, Snap! was designed to teach computer science concepts to an older audience. Creativity was a focus, but not enough to justify the adoption of Flash over HTML5.</p></section><section data-mw-section-id="1" data-parsoid="{}"><h2 id="Name_Change" data-parsoid='{"dsr":[1123,1138,2,2]}'>Name Change</h2><p data-parsoid='{"dsr":[1139,1576,0,0]}'>From the beginning of using BYOB in high schools, there were a few complaints about the inappropriateness of the name. Experience has shown that people outside the USA don't understand why this pun could be considered inappropriate, and even in the USA hardly anyone has seen a problem with it. But the few who did complain were <i data-parsoid='{"dsr":[1468,1476,2,2]}'>very</i> emphatic about it, saying that their schools would never allow them to use software with that name.</p><p data-parsoid='{"dsr":[1578,2019,0,0]}'>So, reluctantly, the team looked for a somewhat relevant name that wasn't already the name of a programming language. Nobody really <i data-parsoid='{"dsr":[1710,1719,2,2]}'>loved</i> "Snap," which doesn't suggest much personality, but at least the blocks snap together. Brian Harvey, Snap<i data-parsoid='{"dsr":[1825,1831,2,2]}'>!'</i>s co-developer insisted on adding the exclamation point, for a slight suggestion of personality, and it became italicized after Scratcher nXIII designed the logo, in which it's italicized.</p></section><section data-mw-section-id="2" data-parsoid="{}"><h2 id="New_Features" data-parsoid='{"dsr":[2021,2037,2,2]}'>New Features</h2><p data-parsoid='{"dsr":[2038,2238,0,0]}'>Snap<i data-parsoid='{"dsr":[2042,2047,2,2]}'>!</i> 4.0 reproduces the functionality of BYOB 3.0. In addition, Snap<i data-parsoid='{"dsr":[2111,2116,2,2]}'>!</i> 4.0 introduced first class continuations, Web access, linked lists, and the ability to write custom blocks in JavaScript.</p><section data-mw-section-id="3" data-parsoid="{}"><h4 id="First_Class_Continuations" data-parsoid='{"dsr":[2240,2281,4,4,1,1]}'><b data-parsoid='{"dsr":[2245,2276,3,3]}'>First Class Continuations</b></h4><p data-parsoid='{"dsr":[2282,2906,0,0]}'>Prior to joining the Snap<i data-parsoid='{"dsr":[2307,2312,2,2]}'>!</i> project, Brian Harvey had spent 20 years teaching computer science using what many people consider the best introductory CS textbook, <i data-parsoid='{"dsr":[2447,2500,2,2]}'>Structure and Interpretation of Computer Programs</i> (<i data-parsoid='{"dsr":[2502,2510,2,2]}'>SICP</i>). The course uses the Scheme programming language, although it's not <i data-parsoid='{"dsr":[2580,2589,2,2]}'>about</i> Scheme, because it's the language that provides the greatest versatility in supporting different programming styles with the least amount of syntax to get in the way. Scheme has been the model for BYOB/Snap<i data-parsoid='{"dsr":[2796,2801,2,2]}'>!</i> language design since BYOB 3.0. One of the team's slogans is "Snap<i data-parsoid='{"dsr":[2868,2873,2,2]}'>!</i> is Scheme disguised as Scratch."</p><p data-parsoid='{"dsr":[2908,3318,0,0]}'>BYOB 3.0 was perhaps 90% of a Scheme implementation, enough to teach a <i data-parsoid='{"dsr":[2979,2987,2,2]}'>SICP</i>-based course, but missing two main advanced capabilities. One, macros, is half-implemented since BYOB 3.0, namely the ability for a custom block to have unevaluated inputs. (The other half, the ability to inject code into the caller of the block, is still to come.) The second big advanced capability is first class continuations.</p><p data-parsoid='{"dsr":[3320,3701,0,0]}'>The <i data-parsoid='{"dsr":[3324,3340,2,2]}'>continuation</i> of a block in a script is the part of the computation that remains to be done when that block has been run. For a command block, this generally means the blocks below it in the script (plus whatever remains of the script that called this block, and so on). For a reporter, it means the block to which this block provides an input, plus whatever comes below it.</p><p data-parsoid='{"dsr":[3703,4346,0,0]}'>Continuations are not a special feature of Scheme. Any part of a computation, in any language, has a continuation—whatever is left to do after it finishes. But in most languages, the programmer isn't called upon to think of the continuation as a <i data-parsoid='{"dsr":[3951,3961,2,2]}'>thing,</i> although the implementor of the programming language does think about continuations. What's special about Scheme is that it treats continuations as first class data. Giving the programmer access to continuations allows users to write any control structure; the most common examples are nonlocal exit (<b data-parsoid='{"dsr":[4263,4274,3,3]}'>catch</b> and <b data-parsoid='{"dsr":[4279,4290,3,3]}'>throw</b> in the Snap<i data-parsoid='{"dsr":[4302,4307,2,2]}'>!</i> tools library) and a thread scheduler.</p><p data-parsoid='{"dsr":[4348,4583,0,0]}'>Even <i data-parsoid='{"dsr":[4353,4361,2,2]}'>SICP</i> doesn't teach first class continuations as an introductory topic, although it does teach a related idea, "Template:Wp." Adding first class continuations to Snap<i data-parsoid='{"dsr":[4522,4527,2,2]}'>!</i> was more planting a flag than meeting a practical need.</p><p data-parsoid='{"dsr":[4585,4629,0,0]}'>The feature is embodied in these two blocks.</p><pre class="blocks-2" typeof="mw:Extension/scratchblocks" about="#mwt2" data-parsoid='{"dsr":[4630,4808,27,16]}' data-mw='{"name":"scratchblocks","attrs":{"version":"2"},"body":{"extsrc":"run ({ :: #fff} :: grey ring) with continuation :: control stack\n(call (( :: #fff) :: grey ring) with continuation :: control reporter)"}}'>run ({ :: #fff} :: grey ring) with continuation :: control stack
(call (( :: #fff) :: grey ring) with continuation :: control reporter)</pre></section><section data-mw-section-id="4" data-parsoid="{}"><h4 id="Web_access" data-parsoid='{"dsr":[4810,4830,4,4,1,1]}'>Web access</h4><pre class="blocks-2" typeof="mw:Extension/scratchblocks" about="#mwt4" data-parsoid='{"dsr":[4831,4914,27,16]}' data-mw='{"name":"scratchblocks","attrs":{"version":"2"},"body":{"extsrc":"(http:// [snap.berkeley.edu] :: sensing)"}}'>(http:// [snap.berkeley.edu] :: sensing)</pre><p data-parsoid='{"dsr":[4915,5320,0,0]}'>Snap<i data-parsoid='{"dsr":[4919,4924,2,2]}'>!</i> 4.0 introduced this block (later renamed <b data-parsoid='{"dsr":[4966,4975,3,3]}'>url</b> to allow https connections), which reads a Web page and reports the contents of the page (typically HTML code). This turned out to be less useful than hoped, because browsers restrict "cross-site" references for security reasons. Sometimes a "CORS proxy" site can be used to get around the problem; details are beyond the scope of this article.</p></section><section data-mw-section-id="5" data-parsoid="{}"><h4 id="Linked_lists" data-parsoid='{"dsr":[5322,5344,4,4,1,1]}'>Linked lists</h4><p data-parsoid='{"dsr":[5345,5926,0,0]}'>The data structure that Scratch (and therefore BYOB) calls a "list" is actually implemented as a <i data-parsoid='{"dsr":[5442,5460,2,2]}'>dynamic array,</i> i.e., a contiguous block of memory that is expanded as needed. A <i data-parsoid='{"dsr":[5526,5541,2,2]}'>linked list</i> is a different data structure made out of <i data-parsoid='{"dsr":[5584,5594,2,2]}'>pairs;</i> each pair contains one list item plus a pointer to another pair, so the entire list contains as many pairs as items, and they don't have to be contiguous in memory. As it turns out, dynamic arrays are most efficient in sequential, imperative programming, while linked lists are more efficient for recursive, functional programming.</p><p data-parsoid='{"dsr":[5928,6062,0,0]}'>For example, given a list of numbers, the goal is to make a list in which every item is two times the corresponding item of the input.</p><pre class="blocks-2" typeof="mw:Extension/scratchblocks" about="#mwt6" data-parsoid='{"dsr":[6064,6751,27,16]}' data-mw='{"name":"scratchblocks","attrs":{"version":"2"},"body":{"extsrc":"\nset [doubled list v] to (double (list) :: list)\n\n(double (list) :: list) :: control hat // Iterative definition\nscript variables ((i) :: grey) ((new list) :: grey) \\&amp;lt; \\&amp;gt; :: grey\nset [i v] to [1]\nset [new list v] to (list \\&amp;gt; :: list)\nfor (item) in (list) {\nreplace item (i) of (new list) with ((item) * (2))\n} :: list\nreport (new list) :: control cap\n\n(double (list) :: list) :: control hat // Recursive definition\nif &amp;lt;is (list) empty? :: list&amp;gt; :: control\nreport (list \\&amp;gt; :: list) :: control cap\nend\nreport (((item (1 v) of (list)) * (2)) in front of (double (all but first of (list) :: list) :: list) :: list) :: control cap\n"}}'>set [doubled list v] to (double (list) :: list)

(double (list) :: list) :: control hat // Iterative definition
script variables ((i) :: grey) ((new list) :: grey) \&amp;lt; \&amp;gt; :: grey
set [i v] to [1]
set [new list v] to (list \&amp;gt; :: list)
for (item) in (list) {
replace item (i) of (new list) with ((item) * (2))
} :: list
report (new list) :: control cap

(double (list) :: list) :: control hat // Recursive definition
if &amp;lt;is (list) empty? :: list&amp;gt; :: control
report (list \&amp;gt; :: list) :: control cap
end
report (((item (1 v) of (list)) * (2)) in front of (double (all but first of (list) :: list) :: list) :: list) :: control cap
</pre><p data-parsoid='{"dsr":[6753,6928,0,0]}'>In the iterative version, the <b data-parsoid='{"dsr":[6783,6792,3,3]}'>add</b> command block extends the size of the list by one item each time it's invoked. This kind of list access is fastest with dynamic arrays.</p><p data-parsoid='{"dsr":[6930,7174,0,0]}'>In the recursive version, the <b data-parsoid='{"dsr":[6960,6977,3,3]}'>in front of</b> block creates a new pair, whose left half is a new item, and whose right half is (a pointer to) the result of the recursive call, namely a sublist of the result. This is fastest with linked lists.</p><p data-parsoid='{"dsr":[7176,7935,0,0]}'>It is a goal of Snap<i data-parsoid='{"dsr":[7196,7201,2,2]}'>!</i> that users not have to know anything about data structures, but should still have their project run as fast as possible. Therefore, Snap<i data-parsoid='{"dsr":[7338,7343,2,2]}'>!</i> automatically creates linked lists when the reporters (<b data-parsoid='{"dsr":[7399,7409,3,3]}'>item</b>, <b data-parsoid='{"dsr":[7411,7433,3,3]}'>all but first of</b>, <b data-parsoid='{"dsr":[7435,7452,3,3]}'>in front of</b>) are used, but creates dynamic arrays when the commands (<b data-parsoid='{"dsr":[7510,7519,3,3]}'>add</b>, <b data-parsoid='{"dsr":[7521,7533,3,3]}'>insert</b>, <b data-parsoid='{"dsr":[7535,7548,3,3]}'>replace</b>, <b data-parsoid='{"dsr":[7550,7562,3,3]}'>delete</b>) are used. The only time the resulting programs aren't as efficient as possible is if the user uses both styles of programming with the same list, which must then be converted from one form to the other. (It should be noted that none of this matters for small lists. It becomes important in "big data" projects that have lists of, perhaps, hundreds of thousands of items.)</p></section><section data-mw-section-id="6" data-parsoid="{}"><h4 id="JavaScript_in_custom_blocks" data-parsoid='{"dsr":[7937,7974,4,4,1,1]}'>JavaScript in custom blocks</h4><p data-parsoid='{"dsr":[7974,8055,0,0]}'>Probably the most important new thing in Snap<i data-parsoid='{"dsr":[8020,8025,2,2]}'>!</i> 4.0 has turned out to be the</p><pre class="blocks-2" typeof="mw:Extension/scratchblocks" about="#mwt8" data-parsoid='{"dsr":[8055,8150,27,16]}' data-mw='{"name":"scratchblocks","attrs":{"version":"2"},"body":{"extsrc":"(JavaScript function [] \\&amp;lt; \\&amp;gt; [] :: operators)"}}'>(JavaScript function [] \&amp;lt; \&amp;gt; [] :: operators)</pre><p data-parsoid='{"dsr":[8150,8302,0,0]}'>block. In this example, never mind what it actually does; instead, notice how inputs are passed from the Snap<i data-parsoid='{"dsr":[8260,8265,2,2]}'>!</i> environment to the JavaScript world.</p><p data-parsoid='{"dsr":[8304,8366,0,0]}'><span class="mw-default-size" typeof="mw:Image" data-parsoid='{"optList":[{"ck":"link","ak":"link=Special:FilePath/Speak-block.png"}],"dsr":[8304,8366,null,null]}'><a href="./Special:FilePath/Speak-block.png" data-parsoid="{}"><img resource="./File:Speak-block.png" src="https://static.miraheze.org/snapwikiwiki/7/7b/Speak-block.png" data-file-width="639" data-file-height="254" data-file-type="bitmap" height="254" width="639" data-parsoid='{"a":{"resource":"./File:Speak-block.png","height":"254","width":"639"},"sa":{"resource":"File:speak-block.png"}}'></a></span></p><p data-parsoid='{"dsr":[8368,8663,0,0]}'>This example comes from a text-to-speech library. Many libraries have been written by advanced users; writing libraries is a way users who think they've learned everything Snap<i data-parsoid='{"dsr":[8544,8549,2,2]}'>!</i> has to teach can explore JavaScript programming while remaining in, and contributing to, the Snap<i data-parsoid='{"dsr":[8647,8652,2,2]}'>!</i> community.</p></section><section data-mw-section-id="7" data-parsoid="{}"><h3 id="Snap!_4.1_Features" data-parsoid='{"dsr":[8665,8732,3,3,-1,1]}'><span id="Snap.21_4.1_Features" typeof="mw:FallbackId" data-parsoid='{"dsr":[8668,8668,null,null]}'></span><span id="Snap!_4.1_Features" data-parsoid='{"stx":"html","dsr":[8669,8706,30,7]}'></span>Snap<i data-parsoid='{"dsr":[8710,8715,2,2]}'>!</i> 4.1 Features</h3><p data-parsoid='{"dsr":[8733,9022,0,0]}'>Snap<i data-parsoid='{"dsr":[8737,8742,2,2]}'>!</i> 4.1, released Oct. 22, 2017, added first class sprites with inheritance, as in BYOB 3.1, except that the distinction between permanent and temporary clones was added, and all attributes of the parent are initially shared with the child. Also, costumes and sounds are first class.</p></section><section data-mw-section-id="8" data-parsoid="{}"><h3 id="Snap!_4.2_Features" data-parsoid='{"dsr":[9024,9091,3,3,-1,1]}'><span id="Snap.21_4.2_Features" typeof="mw:FallbackId" data-parsoid='{"dsr":[9027,9027,null,null]}'></span><span id="Snap!_4.2_Features" data-parsoid='{"stx":"html","dsr":[9028,9065,30,7]}'></span>Snap<i data-parsoid='{"dsr":[9069,9074,2,2]}'>!</i> 4.2 Features</h3><p data-parsoid='{"dsr":[9092,9361,0,0]}'>Snap<i data-parsoid='{"dsr":[9096,9101,2,2]}'>!</i> 4.2, released June 22, 2018, most notably added automatic backup of projects stored in the cloud, so users can recover from disasters such as saving an empty project with the same name as an important one. It also has the beginning of a vector costume editor.</p></section><section data-mw-section-id="9" data-parsoid="{}"><h3 id="Many_Other_Features" data-parsoid='{"dsr":[9363,9390,3,3,1,1]}'>Many Other Features</h3><p data-parsoid='{"dsr":[9391,9646,0,0]}'>Each release added dozens of features not discussed here, because they don't rise to the level of importance of custom blocks, first class procedures, first class lists, first class sprites, and first class continuations. Here are a representative sample:</p><section data-mw-section-id="10" data-parsoid="{}"><h4 id="Generic_Hat_Block" data-parsoid='{"dsr":[9648,9675,4,4,1,1]}'>Generic Hat Block</h4><pre class="blocks-2" typeof="mw:Extension/scratchblocks" about="#mwt10" data-parsoid='{"dsr":[9676,9747,27,16]}' data-mw='{"name":"scratchblocks","attrs":{"version":"2"},"body":{"extsrc":"when &amp;lt;&amp;gt; :: control hat"}}'>when &amp;lt;&amp;gt; :: control hat</pre><p data-parsoid='{"dsr":[9749,10430,0,0]}'>Custom hat blocks have been a frequent user request since the early days of custom blocks. The <i data-parsoid='{"dsr":[9844,9860,2,2]}'>generic when</i> block, introduced in 4.0, answers that need. The feature required particularly careful design, because the script is in a sense always running an implicit <i data-parsoid='{"dsr":[10016,10030,2,2]}'>forever if</i>, so it could slow down projects using it, even if the user tries to stop all scripts. To avoid this problem, generic hat blocks, unlike all other hat blocks, are disabled by the red stop button or by a <code class="blocks" data-parsoid='{"stx":"html","dsr":[10233,10284,21,7]}'>stop all<span typeof="mw:DisplaySpace" data-parsoid='{"dsr":[10262,10263,0,0]}'> </span>:: control cap</code> block. Some other script must run, either because an event triggers its hat block or because the user clicks it, to re-enable generic hat blocks.</p></section><section data-mw-section-id="11" data-parsoid="{}"><h4 id="Zebra_Coloring" data-parsoid='{"dsr":[10432,10456,4,4,1,1]}'>Zebra Coloring</h4><p data-parsoid='{"dsr":[10457,10981,0,0]}'><br data-parsoid='{"dsr":[10458,10458,0,0]}'>This feature, introduced in BYOB 3.0, is representative of the careful attention to the user interface in BYOB/Snap<i data-parsoid='{"dsr":[10574,10579,2,2]}'>!</i>. When same-color blocks are nested, it's hard to see the borders between them. Zebra coloring assigns <i data-parsoid='{"dsr":[10682,10689,2,2]}'>two</i> colors to each palette category, the normal color and a lighter color. When same-color blocks are nested, the outermost one has the normal color, and an inner block takes the opposite color from the one just outside it. The text inside light color blocks is black, instead of white as usual.</p></section><section data-mw-section-id="12" data-parsoid="{}"><h4 id="Detailed_Mouse_Event_Hat_Block" data-parsoid='{"dsr":[10983,11023,4,4,1,1]}'>Detailed Mouse Event Hat Block</h4><p data-parsoid='{"dsr":[11024,11329,0,0]}'><br data-parsoid='{"dsr":[11025,11025,0,0]}'>Since 4.1, users can detect all mouse events, not just clicks. (The "stopped" option was added in 4.2, to allow physical robot packages to detect clicking the stop button and stop the robot's motors. To prevent runaway scripts, a "when I am stopped" script is allowed to run for only one display cycle.)</p></section><section data-mw-section-id="13" data-parsoid="{}"><h4 id="Pause_and_Visual_Stepping" data-parsoid='{"dsr":[11331,11387,4,4,1,1]}'>Pause and <a rel="mw:WikiLink" href="./Visible_Stepping" title="Visible Stepping" data-parsoid='{"stx":"piped","a":{"href":"./Visible_Stepping"},"sa":{"href":"Visible Stepping"},"dsr":[11346,11382,19,2]}'>Visual Stepping</a></h4><p data-parsoid='{"dsr":[11388,11778,0,0]}'>Since 3.0, the menu bar has included a <i data-parsoid='{"dsr":[11427,11436,2,2]}'>pause</i> button, between the green flag and the stop sign. Clicking the button pauses the thread scheduler and replaces the "pause" icon with a yellow "play" icon. Clicking again continues running the project. There is also a <code class="blocks" data-parsoid='{"stx":"html","dsr":[11654,11702,21,7]}'>pause all<span typeof="mw:DisplaySpace" data-parsoid='{"dsr":[11684,11685,0,0]}'> </span>:: control</code> block that can be inserted in a script to set a breakpoint while debugging.</p><p data-parsoid='{"dsr":[11780,12314,0,0]}'>Since 4.0, the <i data-parsoid='{"dsr":[11795,11814,2,2]}'>visual stepping</i> feature from Scratch 1.4 (in which it's misleadingly named <a rel="mw:WikiLink" href="./Single_Stepping" title="Single Stepping" data-parsoid='{"stx":"simple","a":{"href":"./Single_Stepping"},"sa":{"href":"Single Stepping"},"dsr":[11874,11893,2,2]}'>Single Stepping</a>) is controlled by a menu bar button (with the feet icon), and a slider that appears when the button is clicked that controls the speed. If the slider is all the way to the left, true <i data-parsoid='{"dsr":[12077,12096,2,2]}'>single stepping</i> is used: the pause button must be clicked for each step. If a custom block is edited after enabling visual stepping, then the stepping includes the blocks inside that edit window. (More than one editor can be opened.)</p></section><section data-mw-section-id="14" data-parsoid="{}"><h4 id="First_Class_Costumes_and_Pen_Trails" data-parsoid='{"dsr":[12316,12361,4,4,1,1]}'>First Class Costumes and Pen Trails</h4><p data-parsoid='{"dsr":[12362,12615,0,0]}'>Snap! 4.1 added a <code class="blocks" data-parsoid='{"stx":"html","dsr":[12380,12434,21,7]}'>pen trails<span typeof="mw:DisplaySpace" data-parsoid='{"dsr":[12411,12412,0,0]}'> </span>:: pen reporter</code> block that reports everything currently drawn or stamped on the stage as a costume, which can now be passed into and out of custom blocks and stored in variables like other values.</p></section></section></section><section data-mw-section-id="15" data-parsoid="{}"><h2 id="Intellectual_Precursors" data-parsoid='{"dsr":[12617,12646,2,2,1,1]}'>Intellectual Precursors</h2><section data-mw-section-id="16" data-parsoid="{}"><h3 id="Custom_Blocks" data-parsoid='{"dsr":[12648,12669,3,3,1,1]}'>Custom Blocks</h3><p data-parsoid='{"dsr":[12670,13223,0,0]}'>The ability to write and invoke procedures, which is the core idea of Build Your Own Blocks, has been part of almost every programming language (with hardware support in every processor design at least to the extent of an instruction to save the return address somewhere before jumping to the procedure) in the history of computing. (In the original Fortran, the first general-purpose high level programming language, procedures were not reentrant, like Scratch scripts, which break off in the middle if the event that started the script happens again.)</p><p data-parsoid='{"dsr":[13225,13248,0,0]}'>File:Mapwithexample.png</p><p data-parsoid='{"dsr":[13250,13269,0,0]}'>File:Glide BYOB.png</p><p data-parsoid='{"dsr":[13271,13861,0,0]}'>Among languages intended primarily for children, there were heated debates between BASIC and Logo advocates because the latter included support for recursive procedures and the former did not, limiting itself instead to something pretty similar to the <code class="blocks" data-parsoid='{"stx":"html","dsr":[13523,13574,21,7]}'>broadcast [ v] and wait</code> block. There's an irony in this, since the Scratch Team is a descendant of the old MIT Logo Lab. Seymour Papert, one of Logo's inventors and the founder of the MIT Logo Lab, argued for recursion as one of the mathematical big ideas that children should learn from programming computers.</p></section><section data-mw-section-id="17" data-parsoid="{}"><h3 id="First_Class_Data" data-parsoid='{"dsr":[13863,13887,3,3,1,1]}'>First Class Data</h3><p data-parsoid='{"dsr":[13888,14105,0,0]}'>The phrase "first class data" was coined by computer scientist Christopher Strachey, who argued in the 1960s that any data type that exists in a language at all should be first class. This means that data of that type</p><ul data-parsoid='{"dsr":[14107,14311,0,0]}'><li data-parsoid='{"dsr":[14107,14140,1,0,1,0]}'>can be the value of a variable.</li><li data-parsoid='{"dsr":[14141,14191,1,0,1,0]}'>can be an input to a procedure (Scratch: block).</li><li data-parsoid='{"dsr":[14192,14225,1,0,1,0]}'>can be reported by a procedure.</li><li data-parsoid='{"dsr":[14226,14276,1,0,1,0]}'>can be a member of an aggregate (Scratch: list).</li><li data-parsoid='{"dsr":[14277,14311,1,0,1,0]}'>can exist without having a name.</li></ul><p data-parsoid='{"dsr":[14313,14698,0,0]}'>It's easy to see why one might want lists of lists; every data structure (trees, heaps, hash tables, etc.) can be constructed out of lists, but not straightforwardly with only lists of text strings. But why should procedures be first class? This was historically a counterintuitive idea, especially because a procedure can not be recursive unless it has a name by which to call itself.</p><p data-parsoid='{"dsr":[14700,15170,0,0]}'>The idea of first class procedures comes ultimately from the 1936 invention by mathematician Alonzo Church of lambda calculus, which is a formal study of the behavior of functions. In 1936 there were only a handful of experimental computers, and no symbolic programming languages, so the fact that lambda calculus turned out to be of practical use (it is the basis for much of the theory of programming languages today) was a great confirmation of the power of the idea.</p><p data-parsoid='{"dsr":[15172,15762,0,0]}'>Church demonstrated that the ability to create and call functions is <i data-parsoid='{"dsr":[15241,15254,2,2]}'>universal</i> Template:- it is all that is needed to perform any computation that can be done at all. (He also proved that there are undecidable problems, which is the reason for the qualifying clause above.) In BYOB terms, this means a programming language with nothing but THE BLOCK and CALL could exist, and still be able to compute any function. (See this BYOB project description for an explanation of how to invent arithmetic from that starting point.) The Greek letter lambda (λ) is Church's name for a gray ring.</p><p data-parsoid='{"dsr":[15763,16060,0,0]}'><br data-parsoid='{"dsr":[15764,15764,0,0]}'>(Of course lambda does not solve the problem of input/output: capturing mouse clicks, drawing pictures on the screen, and so on. Although obviously of crucial practical importance, such input/output activities are not central to the understanding of what a program or a programming language is.)</p><p data-parsoid='{"dsr":[16062,16599,0,0]}'>Church's work influenced actual programming language design by way of John McCarthy's 1958 invention of the Lisp programming language for artificial intelligence research. Lisp is a direct influence on Logo, and therefore an indirect influence on Scratch. The detailed design of first class procedures in Build Your Own Blocks was strongly influenced by Scheme, a Lisp dialect invented in the late 1970s by Gerald Jay Sussman and Guy Steele, which brought Lisp closer to its roots in lambda calculus by introducing lexical scoping rules.</p></section><section data-mw-section-id="18" data-parsoid="{}"><h3 id="Prototyping" data-parsoid='{"dsr":[16601,16620,3,3,1,1]}'>Prototyping</h3><p data-parsoid='{"dsr":[16621,17318,0,0]}'>The <b data-parsoid='{"dsr":[16625,16636,3,3]}'>clone</b> block reports a new object that inherits properties of the parent object. This allows users to create an object hierarchy, as in other OOP languages such as Smalltalk. But unlike Smalltalk, Build Your Own Blocks does not distinguish between classes and instances; every object can be viewed as an instance of its parent or as the class of its children. This form of inheritance is called "prototyping" because the user builds an <i data-parsoid='{"dsr":[17066,17077,2,2]}'>example</i> of a category of sprite rather than building the category as an abstract description. The best known prototyping languages are JavaScript and Self. The particular form of prototyping used in BYOB was inspired by the work of Henry Lieberman.</p></section><section data-mw-section-id="19" data-parsoid="{}"><h3 id="Snap!_4.1_Features_2" data-parsoid='{"dsr":[17320,17348,3,3]}'><span id="Snap.21_4.1_Features_2" typeof="mw:FallbackId" data-parsoid='{"dsr":[17323,17323,null,null]}'></span>Snap<i data-parsoid='{"dsr":[17327,17332,2,2]}'>!</i> 4.1 Features</h3><p data-parsoid='{"dsr":[17349,17750,0,0]}'>Snap<i data-parsoid='{"dsr":[17353,17358,2,2]}'>!</i> 4.1, released Oct. 22, 2017, added first class sprites with inheritance, as in BYOB 3.1, except that the distinction between permanent and temporary clones was added, and all attributes of the parent are initially shared with the child. Also, costumes and sounds are first class and sometimes is apply the creation of hat blocks or cap blocks is deleted this definition is 4.2 snap! version.</p></section><section data-mw-section-id="20" data-parsoid="{}"><h3 id="Snap!_4.2_Features_2" data-parsoid='{"dsr":[17752,17780,3,3]}'><span id="Snap.21_4.2_Features_2" typeof="mw:FallbackId" data-parsoid='{"dsr":[17755,17755,null,null]}'></span>Snap<i data-parsoid='{"dsr":[17759,17764,2,2]}'>!</i> 4.2 Features</h3><p data-parsoid='{"dsr":[17781,18050,0,0]}'>Snap<i data-parsoid='{"dsr":[17785,17790,2,2]}'>!</i> 4.2, released June 22, 2018, most notably added automatic backup of projects stored in the cloud, so users can recover from disasters such as saving an empty project with the same name as an important one. It also has the beginning of a vector costume editor.</p></section></section><script src="https://scratchblocks.github.io/js/scratchblocks-v3.5.2-min.js"></script><script>scratchblocks.renderMatching(`.blocks`, {});</script></body></html>